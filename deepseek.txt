–û—Ç–ª–∏—á–Ω–æ! –°–æ–∑–¥–∞–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é P2P —Å–∏—Å—Ç–µ–º—É –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –æ–ø–∞—Å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–ª—É—á–µ–Ω–Ω–æ–≥–æ –∑–∞–¥–∞–Ω–∏—è. –í–æ—Ç –ø–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞ (–¥–æ–ø–æ–ª–Ω–µ–Ω–Ω–∞—è)
text
p2p-threat-detection/
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ threat_detection/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ detector.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ object_analyzer.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sensor_processor.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ threat_rules.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ objects.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sensors.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ threats.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ p2p/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ network.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ protocol.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ discovery.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main_app.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sensor_panel.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ threat_view.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ config_loader.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ data_processor.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ logger.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ web_app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ static/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ js/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ images/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.html
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard.html
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sensors.html
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ settings.html
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app.py
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ default.yaml
‚îÇ   ‚îú‚îÄ‚îÄ threat_rules.yaml
‚îÇ   ‚îî‚îÄ‚îÄ sensors.yaml
‚îÇ
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ sensors/
‚îÇ   ‚îú‚îÄ‚îÄ objects/
‚îÇ   ‚îî‚îÄ‚îÄ threats/
‚îÇ
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ test_detector.py
‚îÇ   ‚îú‚îÄ‚îÄ test_network.py
‚îÇ   ‚îî‚îÄ‚îÄ test_objects.py
‚îÇ
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ start_detection_node.py
‚îÇ   ‚îú‚îÄ‚îÄ simulate_sensors.py
‚îÇ   ‚îú‚îÄ‚îÄ add_bootstrap_node.py
‚îÇ   ‚îî‚îÄ‚îÄ monitor_network.py
‚îÇ
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ setup.py
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ .gitignore
–ö–ª—é—á–µ–≤—ã–µ —Ñ–∞–π–ª—ã —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
1. src/threat_detection/models/objects.py
python
from dataclasses import dataclass
from typing import Dict, List, Optional
from enum import Enum
import numpy as np
from datetime import datetime

class ObjectType(Enum):
    UNKNOWN = "unknown"
    AIRCRAFT = "aircraft"
    DRONE = "drone"
    UFO = "ufo"
    BIRD = "bird"
    WEATHER_BALLOON = "weather_balloon"
    DANGEROUS = "dangerous"

class ThreatLevel(Enum):
    NONE = 0
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4

@dataclass
class SensorData:
    timestamp: datetime
    sensor_id: str
    sensor_type: str
    values: Dict[str, float]
    location: Optional[tuple] = None  # (lat, lon, alt)
    confidence: float = 1.0

@dataclass
class DetectedObject:
    object_id: str
    position: tuple  # (x, y, z) coordinates
    velocity: tuple  # (vx, vy, vz) m/s
    size: tuple  # (length, width, height) meters
    temperature: float  # Kelvin
    electromagnetic_emission: float  # W/m¬≤
    magnetic_field: float  # Tesla
    radiation_level: float  # Sieverts/hour
    density: float  # kg/m¬≥
    object_type: ObjectType = ObjectType.UNKNOWN
    threat_level: ThreatLevel = ThreatLevel.NONE
    confidence: float = 0.0
    first_detected: datetime = None
    last_updated: datetime = datetime.now()
    sensor_data: List[SensorData] = None
    
    def __post_init__(self):
        if self.sensor_data is None:
            self.sensor_data = []
        if self.first_detected is None:
            self.first_detected = datetime.now()
    
    def update_from_sensor(self, sensor_data: SensorData):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–∫–∞–∑–∞–Ω–∏–π —Å–µ–Ω—Å–æ—Ä–∞"""
        self.sensor_data.append(sensor_data)
        self.last_updated = datetime.now()
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∏–∑–∏—á–µ—Å–∫–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        for key, value in sensor_data.values.items():
            if hasattr(self, key):
                setattr(self, key, value)
    
    def calculate_threat_score(self) -> float:
        """–†–∞—Å—á–µ—Ç –æ—Ü–µ–Ω–∫–∏ —É–≥—Ä–æ–∑—ã"""
        score = 0.0
        
        # –°–∫–æ—Ä–æ—Å—Ç—å (–≤—ã—Å–æ–∫–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å = –≤—ã—à–µ —É–≥—Ä–æ–∑–∞)
        speed = np.linalg.norm(self.velocity)
        if speed > 1000:  # —Å–≤–µ—Ä—Ö–∑–≤—É–∫–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
            score += 0.3
        elif speed > 300:  # –≤—ã—Å–æ–∫–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
            score += 0.2
        
        # –†–∞–¥–∏–∞—Ü–∏–æ–Ω–Ω–æ–µ –∏–∑–ª—É—á–µ–Ω–∏–µ
        if self.radiation_level > 0.001:  > 1 mSv/h
            score += 0.4 * min(self.radiation_level / 0.01, 1.0)
        
        # –≠–ª–µ–∫—Ç—Ä–æ–º–∞–≥–Ω–∏—Ç–Ω–æ–µ –∏–∑–ª—É—á–µ–Ω–∏–µ
        if self.electromagnetic_emission > 1000:  # —Å–∏–ª—å–Ω–æ–µ –∏–∑–ª—É—á–µ–Ω–∏–µ
            score += 0.2 * min(self.electromagnetic_emission / 10000, 1.0)
        
        # –ú–∞–≥–Ω–∏—Ç–Ω–æ–µ –ø–æ–ª–µ
        if abs(self.magnetic_field) > 0.1:  # —Å–∏–ª—å–Ω–æ–µ –ø–æ–ª–µ
            score += 0.1
        
        # –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ (–∞–Ω–æ–º–∞–ª—å–Ω–∞—è)
        if self.temperature < 100 or self.temperature > 1000:
            score += 0.1
        
        return min(score, 1.0)
2. src/threat_detection/core/detector.py
python
import numpy as np
from typing import List, Dict, Optional
from datetime import datetime, timedelta
from ..models.objects import DetectedObject, ObjectType, ThreatLevel, SensorData
from .threat_rules import ThreatRules

class ThreatDetector:
    def __init__(self, rules: Optional[ThreatRules] = None):
        self.rules = rules or ThreatRules()
        self.detected_objects: Dict[str, DetectedObject] = {}
        self.threat_history: List[dict] = []
    
    def process_sensor_data(self, sensor_data: SensorData) -> Optional[DetectedObject]:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Å —Å–µ–Ω—Å–æ—Ä–∞ –∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤"""
        # –ê–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö —Å–µ–Ω—Å–æ—Ä–∞
        object_id = self._generate_object_id(sensor_data)
        
        if object_id in self.detected_objects:
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –æ–±—ä–µ–∫—Ç–∞
            obj = self.detected_objects[object_id]
            obj.update_from_sensor(sensor_data)
        else:
            # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
            obj = self._create_object_from_sensor(sensor_data, object_id)
            self.detected_objects[object_id] = obj
        
        # –ê–Ω–∞–ª–∏–∑ —É–≥—Ä–æ–∑—ã
        self._analyze_threat(obj)
        
        return obj
    
    def _generate_object_id(self, sensor_data: SensorData) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è ID –æ–±—ä–µ–∫—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö —Å–µ–Ω—Å–æ—Ä–∞"""
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–∑–∏—Ü–∏—é –∏ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –¥–ª—è ID
        pos = sensor_data.location or (0, 0, 0)
        unique_str = f"{pos[0]:.6f}_{pos[1]:.6f}_{sensor_data.sensor_id}"
        return hashlib.md5(unique_str.encode()).hexdigest()[:16]
    
    def _create_object_from_sensor(self, sensor_data: SensorData, object_id: str) -> DetectedObject:
        """–°–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ –∏–∑ –¥–∞–Ω–Ω—ã—Ö —Å–µ–Ω—Å–æ—Ä–∞"""
        values = sensor_data.values
        
        return DetectedObject(
            object_id=object_id,
            position=sensor_data.location or (0, 0, 0),
            velocity=values.get('velocity', (0, 0, 0)),
            size=values.get('size', (1, 1, 1)),
            temperature=values.get('temperature', 293.15),
            electromagnetic_emission=values.get('em_emission', 0),
            magnetic_field=values.get('magnetic_field', 0),
            radiation_level=values.get('radiation', 0),
            density=values.get('density', 1.2),
            sensor_data=[sensor_data]
        )
    
    def _analyze_threat(self, obj: DetectedObject) -> None:
        """–ê–Ω–∞–ª–∏–∑ —É—Ä–æ–≤–Ω—è —É–≥—Ä–æ–∑—ã –æ–±—ä–µ–∫—Ç–∞"""
        threat_score = obj.calculate_threat_score()
        
        # –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è
        is_dangerous = self.rules.apply_rules(obj, threat_score)
        
        if is_dangerous:
            obj.threat_level = ThreatLevel.CRITICAL
            obj.object_type = ObjectType.DANGEROUS
            
            # –ó–∞–ø–∏—Å—å –≤ –∏—Å—Ç–æ—Ä–∏—é —É–≥—Ä–æ–∑
            self.threat_history.append({
                'timestamp': datetime.now(),
                'object_id': obj.object_id,
                'threat_score': threat_score,
                'position': obj.position,
                'reason': "Automatic threat detection"
            })
        
        elif threat_score > 0.7:
            obj.threat_level = ThreatLevel.HIGH
        elif threat_score > 0.5:
            obj.threat_level = ThreatLevel.MEDIUM
        elif threat_score > 0.3:
            obj.threat_level = ThreatLevel.LOW
        else:
            obj.threat_level = ThreatLevel.NONE
    
    def get_active_threats(self) -> List[DetectedObject]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö —É–≥—Ä–æ–∑"""
        return [obj for obj in self.detected_objects.values() 
                if obj.threat_level.value >= ThreatLevel.MEDIUM.value]
    
    def cleanup_old_objects(self, max_age_minutes: int = 60):
        """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤"""
        cutoff_time = datetime.now() - timedelta(minutes=max_age_minutes)
        to_remove = []
        
        for obj_id, obj in self.detected_objects.items():
            if obj.last_updated < cutoff_time:
                to_remove.append(obj_id)
        
        for obj_id in to_remove:
            del self.detected_objects[obj_id]
3. src/threat_detection/core/threat_rules.py
python
import yaml
from pathlib import Path
from typing import Dict, Any
from ..models.objects import DetectedObject

class ThreatRules:
    def __init__(self, config_path: str = None):
        self.rules = self._load_rules(config_path)
    
    def _load_rules(self, config_path: str) -> Dict[str, Any]:
        """–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–∞–≤–∏–ª –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞"""
        default_rules = {
            'min_threat_score': 0.8,
            'velocity_threshold': 300,  # m/s
            'radiation_threshold': 0.001,  # Sv/h
            'em_emission_threshold': 1000,  # W/m¬≤
            'magnetic_field_threshold': 0.1,  # Tesla
            'temperature_range': {
                'min': 100,  # K
                'max': 1000  # K
            },
            'size_threshold': 50,  # meters
            'pattern_rules': [
                {
                    'name': 'rapid_movement',
                    'condition': 'velocity > 500 and size < 10',
                    'threat_score': 0.6
                },
                {
                    'name': 'high_radiation',
                    'condition': 'radiation_level > 0.01',
                    'threat_score': 0.9
                }
            ]
        }
        
        if config_path and Path(config_path).exists():
            try:
                with open(config_path, 'r') as f:
                    return yaml.safe_load(f)
            except Exception as e:
                print(f"Error loading rules config: {e}")
        
        return default_rules
    
    def apply_rules(self, obj: DetectedObject, base_score: float) -> bool:
        """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —É–≥—Ä–æ–∑"""
        score = base_score
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Ä–æ–≥–æ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
        rules = self.rules
        
        # –í—ã—Å–æ–∫–∞—è —Ä–∞–¥–∏–∞—Ü–∏—è
        if obj.radiation_level > rules['radiation_threshold']:
            score += 0.2
        
        # –°–∏–ª—å–Ω–æ–µ EM –∏–∑–ª—É—á–µ–Ω–∏–µ
        if obj.electromagnetic_emission > rules['em_emission_threshold']:
            score += 0.15
        
        # –ê–Ω–æ–º–∞–ª—å–Ω–æ–µ –º–∞–≥–Ω–∏—Ç–Ω–æ–µ –ø–æ–ª–µ
        if abs(obj.magnetic_field) > rules['magnetic_field_threshold']:
            score += 0.1
        
        # –ê–Ω–æ–º–∞–ª—å–Ω–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞
        temp_rules = rules['temperature_range']
        if obj.temperature < temp_rules['min'] or obj.temperature > temp_rules['max']:
            score += 0.1
        
        # –ë–æ–ª—å—à–æ–π —Ä–∞–∑–º–µ—Ä
        max_size = max(obj.size)
        if max_size > rules['size_threshold']:
            score += 0.1
        
        # –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å–ª–æ–∂–Ω—ã—Ö –ø—Ä–∞–≤–∏–ª
        for pattern_rule in rules.get('pattern_rules', []):
            if self._check_pattern(obj, pattern_rule['condition']):
                score += pattern_rule['threat_score']
        
        return score >= rules['min_threat_score']
    
    def _check_pattern(self, obj: DetectedObject, condition: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–ª–æ–∂–Ω–æ–≥–æ —É—Å–ª–æ–≤–∏—è"""
        try:
            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —É—Å–ª–æ–≤–∏—è
            local_vars = {
                'velocity': np.linalg.norm(obj.velocity),
                'size': max(obj.size),
                'radiation_level': obj.radiation_level,
                'temperature': obj.temperature,
                'em_emission': obj.electromagnetic_emission,
                'magnetic_field': abs(obj.magnetic_field),
                'density': obj.density
            }
            
            # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π (–≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω—ã–π eval)
            # –ó–¥–µ—Å—å —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
            if 'velocity > 500' in condition and local_vars['velocity'] > 500:
                return True
            if 'radiation_level > 0.01' in condition and local_vars['radiation_level'] > 0.01:
                return True
                
            return False
        except:
            return False
4. src/threat_detection/p2p/network.py
python
import asyncio
import json
import hashlib
from typing import Dict, List, Optional
from datetime import datetime
from ..models.objects import DetectedObject, SensorData
from .protocol import P2PProtocol, MessageType

class ThreatDetectionNode(P2PProtocol):
    def __init__(self, host: str = 'localhost', port: int = 6000, 
                 node_id: Optional[str] = None):
        super().__init__(host, port, node_id)
        self.detected_objects: Dict[str, DetectedObject] = {}
        self.shared_threats: Dict[str, dict] = {}
        self.known_nodes: set = set()
        
        # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–æ–±—â–µ–Ω–∏–π
        self.message_handlers.update({
            MessageType.THREAT_ALERT: self._handle_threat_alert,
            MessageType.OBJECT_UPDATE: self._handle_object_update,
            MessageType.SENSOR_DATA: self._handle_sensor_data
        })
    
    async def start(self):
        """–ó–∞–ø—É—Å–∫ —É–∑–ª–∞"""
        await super().start()
        print(f"Threat Detection Node started: {self.node_id}")
        
        # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏
        asyncio.create_task(self._broadcast_threats_periodically())
        asyncio.create_task(self._cleanup_old_data())
    
    async def _handle_threat_alert(self, message: dict, peer_id: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–ø–æ–≤–µ—â–µ–Ω–∏—è –æ–± —É–≥—Ä–æ–∑–µ"""
        threat_data = message['data']
        threat_id = threat_data['threat_id']
        
        if threat_id not in self.shared_threats:
            self.shared_threats[threat_id] = {
                **threat_data,
                'received_from': peer_id,
                'timestamp': datetime.now()
            }
            
            print(f"üö® THREAT ALERT from {peer_id}: {threat_data['object_id']}")
            
            # –†–µ—Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è –¥—Ä—É–≥–∏–º –ø–∏—Ä–∞–º
            await self.broadcast_message(message, exclude_peers=[peer_id])
    
    async def _handle_object_update(self, message: dict, peer_id: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–∞"""
        obj_data = message['data']
        obj_id = obj_data['object_id']
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞
        if obj_id in self.detected_objects:
            self.detected_objects[obj_id].update_from_dict(obj_data)
        else:
            obj = DetectedObject.from_dict(obj_data)
            self.detected_objects[obj_id] = obj
    
    async def _handle_sensor_data(self, message: dict, peer_id: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Å —Å–µ–Ω—Å–æ—Ä–∞"""
        sensor_data_dict = message['data']
        sensor_data = SensorData.from_dict(sensor_data_dict)
        
        # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–∞–Ω–Ω—ã—Ö —Å–µ–Ω—Å–æ—Ä–∞
        print(f"Received sensor data from {peer_id}: {sensor_data.sensor_type}")
    
    async def broadcast_threat_alert(self, obj: DetectedObject):
        """–®–∏—Ä–æ–∫–æ–≤–µ—â–∞—Ç–µ–ª—å–Ω–æ–µ –æ–ø–æ–≤–µ—â–µ–Ω–∏–µ –æ–± —É–≥—Ä–æ–∑–µ"""
        threat_message = {
            'type': MessageType.THREAT_ALERT.value,
            'data': {
                'threat_id': hashlib.md5(obj.object_id.encode()).hexdigest(),
                'object_id': obj.object_id,
                'position': obj.position,
                'threat_level': obj.threat_level.value,
                'timestamp': datetime.now().isoformat(),
                'confidence': obj.confidence
            }
        }
        
        await self.broadcast_message(threat_message)
    
    async def share_object_data(self, obj: DetectedObject):
        """–û–±–º–µ–Ω –¥–∞–Ω–Ω—ã–º–∏ –æ–± –æ–±—ä–µ–∫—Ç–µ"""
        obj_message = {
            'type': MessageType.OBJECT_UPDATE.value,
            'data': obj.to_dict()
        }
        
        await self.broadcast_message(obj_message)
    
    async def _broadcast_threats_periodically(self):
        """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± —É–≥—Ä–æ–∑–∞—Ö"""
        while True:
            await asyncio.sleep(30)  # –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
            
            # –û—Ç–ø—Ä–∞–≤–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —É–≥—Ä–æ–∑
            critical_threats = [obj for obj in self.detected_objects.values()
                               if obj.threat_level.value >= 3]
            
            for threat in critical_threats:
                await self.broadcast_threat_alert(threat)
    
    async def _cleanup_old_data(self):
        """–û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
        while True:
            await asyncio.sleep(300)  # –ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
            
            current_time = datetime.now()
            to_remove = []
            
            for obj_id, obj in self.detected_objects.items():
                if (current_time - obj.last_updated).total_seconds() > 3600:  > 1 —á–∞—Å
                    to_remove.append(obj_id)
            
            for obj_id in to_remove:
                del self.detected_objects[obj_id]
5. src/threat_detection/p2p/protocol.py
python
import asyncio
import json
import hashlib
from enum import Enum
from typing import Dict, List, Optional, Set

class MessageType(Enum):
    PEER_DISCOVERY = "peer_discovery"
    THREAT_ALERT = "threat_alert"
    OBJECT_UPDATE = "object_update"
    SENSOR_DATA = "sensor_data"
    PING = "ping"
    PONG = "pong"

class P2PProtocol:
    def __init__(self, host: str = 'localhost', port: int = 6000, 
                 node_id: Optional[str] = None):
        self.host = host
        self.port = port
        self.node_id = node_id or self._generate_node_id()
        self.peers: Dict[str, asyncio.StreamWriter] = {}
        self.server: Optional[asyncio.Server] = None
        self.running = False
        
        self.message_handlers = {
            MessageType.PEER_DISCOVERY: self._handle_peer_discovery,
            MessageType.PING: self._handle_ping,
            MessageType.PONG: self._handle_pong
        }
    
    def _generate_node_id(self) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ ID —É–∑–ª–∞"""
        unique_str = f"{self.host}:{self.port}:{asyncio.get_event_loop().time()}"
        return hashlib.sha256(unique_str.encode()).hexdigest()[:16]
    
    async def start(self):
        """–ó–∞–ø—É—Å–∫ P2P —É–∑–ª–∞"""
        self.server = await asyncio.start_server(
            self._handle_connection, self.host, self.port
        )
        self.running = True
        
        async with self.server:
            await self.server.serve_forever()
    
    async def _handle_connection(self, reader: asyncio.StreamReader, 
                               writer: asyncio.StreamWriter):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–µ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        addr = writer.get_extra_info('peername')
        peer_id = f"{addr[0]}:{addr[1]}"
        
        self.peers[peer_id] = writer
        
        try:
            while self.running:
                data = await reader.read(4096)
                if not data:
                    break
                
                try:
                    message = json.loads(data.decode())
                    await self._process_message(message, peer_id)
                except json.JSONDecodeError:
                    print(f"Invalid JSON from {peer_id}")
                
        except (ConnectionResetError, asyncio.IncompleteReadError):
            print(f"Connection closed by {peer_id}")
        finally:
            self._remove_peer(peer_id)
            writer.close()
            await writer.wait_closed()
    
    async def _process_message(self, message: dict, peer_id: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        try:
            msg_type = MessageType(message['type'])
            handler = self.message_handlers.get(msg_type)
            
            if handler:
                await handler(message, peer_id)
            else:
                print(f"No handler for message type: {msg_type}")
                
        except ValueError:
            print(f"Unknown message type: {message.get('type')}")
    
    async def connect_to_peer(self, host: str, port: int) -> Optional[str]:
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –¥—Ä—É–≥–æ–º—É —É–∑–ª—É"""
        try:
            reader, writer = await asyncio.open_connection(host, port)
            peer_id = f"{host}:{port}"
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º writer –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
            self.peers[peer_id] = writer
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è —ç—Ç–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            asyncio.create_task(self._handle_connection(reader, writer))
            
            print(f"Connected to peer: {peer_id}")
            return peer_id
            
        except Exception as e:
            print(f"Failed to connect to {host}:{port}: {e}")
            return None
    
    async def send_message(self, peer_id: str, message: dict):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –ø–∏—Ä—É"""
        writer = self.peers.get(peer_id)
        if writer and not writer.is_closing():
            try:
                data = json.dumps(message).encode()
                writer.write(data)
                await writer.drain()
            except Exception as e:
                print(f"Failed to send message to {peer_id}: {e}")
                self._remove_peer(peer_id)
    
    async def broadcast_message(self, message: dict, exclude_peers: List[str] = None):
        """–®–∏—Ä–æ–∫–æ–≤–µ—â–∞—Ç–µ–ª—å–Ω–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        exclude_peers = exclude_peers or []
        
        for peer_id in list(self.peers.keys()):
            if peer_id not in exclude_peers:
                await self.send_message(peer_id, message)
    
    def _remove_peer(self, peer_id: str):
        """–£–¥–∞–ª–µ–Ω–∏–µ –ø–∏—Ä–∞ –∏–∑ —Å–ø–∏—Å–∫–∞"""
        if peer_id in self.peers:
            writer = self.peers[peer_id]
            if not writer.is_closing():
                writer.close()
            del self.peers[peer_id]
    
    async def _handle_peer_discovery(self, message: dict, peer_id: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ discovery —Å–æ–æ–±—â–µ–Ω–∏–π"""
        # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ–±–º–µ–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –ø–∏—Ä–∞—Ö
        pass
    
    async def _handle_ping(self, message: dict, peer_id: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ ping —Å–æ–æ–±—â–µ–Ω–∏–π"""
        pong_message = {
            'type': MessageType.PONG.value,
            'data': {'timestamp': message['data']['timestamp']}
        }
        await self.send_message(peer_id, pong_message)
    
    async def _handle_pong(self, message: dict, peer_id: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ pong —Å–æ–æ–±—â–µ–Ω–∏–π"""
        # –ú–æ–∂–Ω–æ –≤—ã—á–∏—Å–ª—è—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É —Å–µ—Ç–∏
        pass
    
    async def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —É–∑–ª–∞"""
        self.running = False
        if self.server:
            self.server.close()
            await self.server.wait_closed()
        
        for writer in self.peers.values():
            if not writer.is_closing():
                writer.close()
        self.peers.clear()
6. scripts/start_detection_node.py
python
#!/usr/bin/env python3
import asyncio
import argparse
from src.threat_detection.p2p.network import ThreatDetectionNode
from src.threat_detection.core.detector import ThreatDetector
from src.threat_detection.utils.logger import setup_logging

async def main():
    parser = argparse.ArgumentParser(description='Threat Detection P2P Node')
    parser.add_argument('--host', default='localhost', help='Host to bind to')
    parser.add_argument('--port', type=int, default=6000, help='Port to listen on')
    parser.add_argument('--bootstrap', help='Bootstrap node (host:port)')
    parser.add_argument('--config', default='config/default.yaml', help='Config file path')
    
    args = parser.parse_args()
    
    setup_logging()
    
    # –°–æ–∑–¥–∞–Ω–∏–µ –∏ –∑–∞–ø—É—Å–∫ —É–∑–ª–∞
    node = ThreatDetectionNode(host=args.host, port=args.port)
    detector = ThreatDetector()
    
    try:
        # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ bootstrap —É–∑–ª—É –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω
        if args.bootstrap:
            bootstrap_host, bootstrap_port = args.bootstrap.split(':')
            await node.connect_to_peer(bootstrap_host, int(bootstrap_port))
        
        # –ó–∞–ø—É—Å–∫ —É–∑–ª–∞
        await node.start()
        
    except KeyboardInterrupt:
        print("\nShutting down...")
    finally:
        await node.stop()

if __name__ == "__main__":
    asyncio.run(main())
7. config/threat_rules.yaml
yaml
min_threat_score: 0.75
velocity_threshold: 300
radiation_threshold: 0.001
em_emission_threshold: 1000
magnetic_field_threshold: 0.1
temperature_range:
  min: 100
  max: 1000
size_threshold: 50
pattern_rules:
  - name: rapid_movement_with_radiation
    condition: velocity > 500 and radiation_level > 0.0005
    threat_score: 0.7
  - name: large_object_high_em
    condition: size > 20 and em_emission > 5000
    threat_score: 0.8
  - name: extreme_temperature
    condition: temperature < 150 or temperature > 800
    threat_score: 0.4
8. Web –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å (src/web_app/app.py)
python
from flask import Flask, render_template, jsonify
from threading import Thread
import asyncio
from src.threat_detection.p2p.network import ThreatDetectionNode

app = Flask(__name__)
detection_node = None

@app.route('/')
def dashboard():
    return render_template('dashboard.html')

@app.route('/api/threats')
def get_threats():
    if detection_node:
        threats = list(detection_node.shared_threats.values())
        return jsonify({'threats': threats})
    return jsonify({'threats': []})

@app.route('/api/objects')
def get_objects():
    if detection_node:
        objects = [obj.to_dict() for obj in detection_node.detected_objects.values()]
        return jsonify({'objects': objects})
    return jsonify({'objects': []})

@app.route('/api/network')
def get_network_info():
    if detection_node:
        peers = list(detection_node.peers.keys())
        return jsonify({
            'node_id': detection_node.node_id,
            'peers': peers,
            'peer_count': len(peers)
        })
    return jsonify({'peers': []})

def run_detection_node():
    global detection_node
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    
    detection_node = ThreatDetectionNode(host='0.0.0.0', port=6000)
    loop.run_until_complete(detection_node.start())

if __name__ == "__main__":
    # –ó–∞–ø—É—Å–∫ P2P —É–∑–ª–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    node_thread = Thread(target=run_detection_node, daemon=True)
    node_thread.start()
    
    # –ó–∞–ø—É—Å–∫ web —Å–µ—Ä–≤–µ—Ä–∞
    app.run(host='0.0.0.0', port=5000, debug=True)
–ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã
–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π:

bash
pip install -r requirements.txt
–ó–∞–ø—É—Å–∫ –ø–µ—Ä–≤–æ–≥–æ —É–∑–ª–∞:

bash
python scripts/start_detection_node.py --port 6000
–ó–∞–ø—É—Å–∫ –≤—Ç–æ—Ä–æ–≥–æ —É–∑–ª–∞ —Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º –∫ –ø–µ—Ä–≤–æ–º—É:

bash
python scripts/start_detection_node.py --port 6001 --bootstrap localhost:6000
–ó–∞–ø—É—Å–∫ web –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞:

bash
python src/web_app/app.py
–°–∏–º—É–ª—è—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö —Å–µ–Ω—Å–æ—Ä–æ–≤:

bash
python scripts/simulate_sensors.py --host localhost --port 6000
–ö–ª—é—á–µ–≤—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏:
–î–µ—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ - P2P —Å–µ—Ç—å –¥–ª—è —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç–∏ –∫ –∞—Ç–∞–∫–∞–º

–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —É–≥—Ä–æ–∑ - –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–Ω–æ–≥–æ—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞

–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π –æ–±–º–µ–Ω –¥–∞–Ω–Ω—ã–º–∏ - —É–∑–ª—ã –æ–±–º–µ–Ω–∏–≤–∞—é—Ç—Å—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± —É–≥—Ä–æ–∑–∞—Ö

–í–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å - –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —É–≥—Ä–æ–∑ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏

–ö–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä—É–µ–º—ã–µ –ø—Ä–∞–≤–∏–ª–∞ - –≥–∏–±–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è

–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å - –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —É–∑–ª–æ–≤ –∏ —Å–µ–Ω—Å–æ—Ä–æ–≤

–°–∏—Å—Ç–µ–º–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –≤—Å–µ–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –∑–∞–¥–∞–Ω–∏—è –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –≥–æ—Ç–æ–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –æ–ø–∞—Å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –¥–µ—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–π P2P —Å–µ—Ç–∏.